use std::sync::{Arc, Weak, RwLock, RwLockReadGuard, RwLockWriteGuard};
use std::collections::hash_map::Entry;
use std::collections::HashMap;
use std::any::{TypeId, Any};

use crate::util::{OwnerRef, OwnerMut};

use std::fmt::Debug;
mod state;
mod property;
pub use state::*;
pub use property::*;

pub mod vanilla;


/// A basic block.
#[derive(Debug)]
pub struct Block {
    name: &'static str,
    shared_data: Arc<BlockSharedData>
}

/// Type alias for block's extension maps
pub type BlockExtMap = HashMap<TypeId, Box<(dyn Any + Send + Sync)>>;

/// Every block has a shared data structure, these data are also shared
/// to its block states. States are also stored in this shared data.
#[derive(Debug)]
pub struct BlockSharedData {
    states: Vec<Arc<BlockState>>,
    default_state: Weak<BlockState>,
    properties: HashMap<&'static str, SharedProperty>,
    extensions: RwLock<BlockExtMap>
}

impl Block {

    pub(crate) fn new(
        name: &'static str,
        state_builder: BlockStateBuilder,
        reg_tid: TypeId,
        uid: &mut u16,
        states_by_uid: &mut HashMap<u16, Weak<BlockState>>
    ) -> Self {

        Block {
            name,
            shared_data: state_builder.build(reg_tid, uid, states_by_uid)
        }

    }

    pub fn get_default_state(&self) -> Arc<BlockState> {
        // SAFETY: Unwrap should never panic if the object is not dropped.
        self.shared_data.default_state.upgrade().unwrap()
    }

    pub fn add_extension<E: Any + Sync + Send>(&self, ext: E) {

        let mut extensions = self.shared_data.extensions.write()
            .expect("The block's extensions are being used, can't add an extension.");

        match extensions.entry(ext.type_id()) {
            Entry::Occupied(_) => println!("This type of extension already set for this block."),
            Entry::Vacant(v) => { v.insert(Box::new(ext)); }
        }

    }

    pub fn get_extension<E: Any + Sync + Send>(&self) -> Option<OwnerRef<RwLockReadGuard<BlockExtMap>, E>> {

        let extensions = self.shared_data.extensions.read()
            .expect("The block's extensions are being mutated, can't get any extension.");

        let ext_box = extensions.get(&TypeId::of::<E>())?;
        let ext = (&**ext_box).downcast_ref::<E>()? as *const E;
        Some(OwnerRef::new_unchecked(extensions, ext))

    }

    pub fn get_extension_mut<E: Any + Sync + Send>(&self) -> Option<OwnerMut<RwLockWriteGuard<BlockExtMap>, E>> {

        let mut extensions = self.shared_data.extensions.write()
            .expect("The block's extensions are being mutated, can't get any extension.");

        let ext_box = extensions.get_mut(&TypeId::of::<E>())?;
        let ext = (&mut **ext_box).downcast_mut::<E>()? as *mut E;
        Some(OwnerMut::new_unchecked(extensions, ext))

    }

}

impl BlockSharedData {

    fn new(properties_count: usize, states_count: usize) -> Self {
        BlockSharedData {
            states: Vec::with_capacity(states_count),
            default_state: Weak::new(),
            properties: HashMap::with_capacity(properties_count),
            extensions: RwLock::new(HashMap::new())
        }
    }

}


/// Trait to implement for all Blocks static registers, like the one generated by `blocks!` macro.
///
/// This requires the implementation of Any ('static) in order to use the TypeId to resolve
/// UID offset.
pub trait StaticBlocks: Any {
    fn get_state(&self, uid: u16) -> Option<Arc<BlockState>>;
    fn get_last_uid(&self) -> u16;
    fn get_block_count(&self) -> u16;
}


/// Effective block register, can be composed of multiple static registers for use in worlds.
pub struct Blocks {
    uid_offset_and_reg: Vec<(u16, &'static dyn StaticBlocks)>,
    uid_offset_by_reg_tid: HashMap<TypeId, u16>,
    next_uid_offset: u16
}

impl Blocks {

    pub fn new() -> Blocks {
        Blocks {
            uid_offset_and_reg: Vec::new(),
            uid_offset_by_reg_tid: HashMap::new(),
            next_uid_offset: 1 // 0 is reserved, like the null-ptr
        }
    }

    pub fn register<B: StaticBlocks>(&mut self, reg: &'static B) {
        self.uid_offset_and_reg.insert(0, (self.next_uid_offset, reg));
        self.uid_offset_by_reg_tid.insert(reg.type_id(), self.next_uid_offset);
        self.next_uid_offset += reg.get_last_uid() + 1;
    }

    pub fn get_state_uid(&self, state: &BlockState) -> u16 {
        if let Some(&offset) = self.uid_offset_by_reg_tid.get(&state.reg_tid) {
            offset + state.uid
        } else {
            panic!("This BlockState is not registered in this Blocks register, first register its static register.");
        }
    }

    pub fn get_state(&self, uid: u16) -> Option<Arc<BlockState>> {
        if uid > 0 {
            for &(uid_offset, reg) in &self.uid_offset_and_reg {
                if uid >= uid_offset {
                    return reg.get_state(uid - uid_offset);
                }
            }
        }
        None
    }

}


#[macro_export]
macro_rules! blocks {
    ($struct_id:ident $static_id:ident [
        $(
            $block_id:ident $block_name:literal $([ $($prop_const:ident),* ])?
        ),*
        $(,)?
    ]) => {

        #[allow(non_snake_case)]
        pub struct $struct_id {
            states_by_uid: std::collections::HashMap<u16, std::sync::Weak<$crate::block::BlockState>>,
            last_uid: u16,
            block_count: u16,
            $( pub $block_id: $crate::block::Block ),*
        }

        impl $struct_id {
            fn load() -> Self {

                use std::collections::HashMap;
                use $crate::block::{Block, BlockStateBuilder};

                let mut uid = 0;
                let tid = std::any::TypeId::of::<Self>();
                let mut states_by_uid = HashMap::new();
                let mut block_count = 0;

                fn increase_block_count(b: Block, c: &mut u16) -> Block {
                    *c += 1;
                    b
                }

                Self {
                    $( $block_id: increase_block_count(Block::new(
                        $block_name,
                        BlockStateBuilder::new() $($( .prop(&$prop_const) )*)?,
                        tid,
                        &mut uid,
                        &mut states_by_uid
                    ), &mut block_count), )*
                    block_count,
                    last_uid: uid,
                    states_by_uid
                }

            }
        }

        impl $crate::block::StaticBlocks for $struct_id {

            fn get_state(&self, uid: u16) -> Option<std::sync::Arc<$crate::block::BlockState>> {
                self.states_by_uid.get(&uid).map(|weak_state| weak_state.upgrade().unwrap())
            }

            fn get_last_uid(&self) -> u16 {
                self.last_uid
            }

            fn get_block_count(&self) -> u16 {
                self.block_count
            }

        }

        #[allow(non_upper_case_globals)]
        pub static $static_id: once_cell::sync::Lazy<$struct_id> = once_cell::sync::Lazy::new(|| $struct_id::load());

    };
}
