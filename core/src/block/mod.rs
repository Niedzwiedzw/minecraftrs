use std::marker::PhantomPinned;
use std::collections::HashMap;
use std::ptr::NonNull;
use std::fmt::Debug;
use std::any::Any;
use std::pin::Pin;

use crate::util::generic::{RwGenericMap, GuardedRef, GuardedMut};
use crate::util::UidGenerator;

mod state;
mod property;
pub use state::*;
pub use property::*;

pub mod vanilla;
pub mod legacy;


/// A basic block defined by a name, its states, properties or extensions.
///
/// A Block can only live in heap memory through a pined box because its states
/// contains a back reference to it. Block and BlockState must not be mutated,
/// only extensions can be 'interior-mutated'.
#[derive(Debug)]
pub struct Block {
    uid: u32,
    name: &'static str,
    states: Vec<BlockState>,
    properties: HashMap<&'static str, SharedProperty>,
    extensions: RwGenericMap,
    default_state_index: usize,
    _marker: PhantomPinned
}

// We enforce Send + Sync because we know that these pointers will never
// be mutated but only immutably referenced.
unsafe impl Send for Block {}
unsafe impl Sync for Block {}

impl Block {

    pub fn new(name: &'static str, state_builder: BlockStateBuilder) -> Pin<Box<Block>> {

        static UID: UidGenerator = UidGenerator::new();

        let (properties, states) = state_builder.build();

        let mut block = Box::pin(Block {
            uid: UID.next(),
            name,
            states,
            properties,
            extensions: RwGenericMap::new(),
            default_state_index: 0,
            _marker: PhantomPinned
        });

        unsafe {

            let block_ref = NonNull::from(&*block);
            let block_mut = block.as_mut().get_unchecked_mut();

            for state in &mut block_mut.states {
                state.set_block(block_ref);
            }

        }

        block

    }

    /// Get the unique ID of this block, this is unique for the process.
    /// This UID is not used for any save operation, for saving purpose,
    /// use `WorkBlocks`.
    pub fn get_uid(&self) -> u32 {
        self.uid
    }

    pub fn get_name(&self) -> &'static str {
        self.name
    }

    pub fn get_default_state(&self) -> &BlockState {
        &self.states[self.default_state_index]
    }

    pub fn get_states(&self) -> &[BlockState] {
        &self.states[..]
    }

    pub fn add_ext<E: Any + Sync + Send>(&self, ext: E) {
        self.extensions.add(ext);
    }

    pub fn get_ext<E: Any + Sync + Send>(&self) -> Option<GuardedRef<E>> {
        self.extensions.get()
    }

    pub fn get_ext_mut<E: Any + Sync + Send>(&self) -> Option<GuardedMut<E>> {
        self.extensions.get_mut()
    }

}


/// Trait to implement for all Blocks static registers, like the one generated by `blocks!` macro.
///
/// This requires the implementation of Any ('static) in order to use the TypeId to resolve
/// UID offset.
pub trait StaticBlocks {
    fn iter_blocks<'a>(&'a self) -> Box<dyn Iterator<Item=&'a Pin<Box<Block>>> + 'a>;
    fn blocks_count(&self) -> usize;
    fn states_count(&self) -> usize;
}


/// Working blocks' registry, use this structure to add individual blocks to the register.
/// This registry maps unique blocks and block states IDs to save IDs (SID).
pub struct WorkBlocks<'a> {
    next_sid: u16, // 0 is reserved, like the null-ptr
    blocks_to_sid: HashMap<u32, u16>,
    sid_to_states: Vec<&'a BlockState>
}

impl<'a> WorkBlocks<'a> {

    pub fn new() -> WorkBlocks<'a> {
        WorkBlocks {
            next_sid: 1,
            blocks_to_sid: HashMap::new(),
            sid_to_states: Vec::new()
        }
    }

    pub fn register(&mut self, block: &'a Pin<Box<Block>>) {
        let block = &**block;
        let block_len = block.states.len();
        let uid = self.next_sid;
        self.next_sid = uid.checked_add(block_len as u16)
            .expect("Too much block in this register.");
        self.blocks_to_sid.insert(block.uid, uid);
        self.sid_to_states.reserve(block_len);
        for state in &block.states {
            self.sid_to_states.push(state);
        }
    }

    pub fn register_static(&mut self, static_blocks: &'a Pin<Box<impl StaticBlocks>>) {
        self.blocks_to_sid.reserve(static_blocks.blocks_count());
        self.sid_to_states.reserve(static_blocks.states_count());
        for block in static_blocks.iter_blocks() {
            self.register(block);
        }
    }

    pub fn get_uid_from(&self, state: &BlockState) -> Option<u16> {
        let block_uid = state.get_block().get_uid();
        let block_offset = *self.blocks_to_sid.get(&block_uid)?;
        Some(block_offset + state.get_uid())
    }

    pub fn get_state_from(&self, uid: u16) -> Option<&'a BlockState> {
        match uid {
            0 => None,
            _ => Some(*self.sid_to_states.get((uid - 1) as usize)?)
        }
    }

    pub fn blocks_count(&self) -> usize {
        self.blocks_to_sid.len()
    }

    pub fn states_count(&self) -> usize {
        self.sid_to_states.len()
    }

}


#[macro_export]
macro_rules! inner_blocks_prop {
    ($state_builder:ident, $prop_const:ident) => {
        $state_builder = $state_builder.prop(&$prop_const);
    };
    ($state_builder:ident, (...$props_group:ident)) => {
        for ptr in &$props_group {
            $state_builder = $state_builder.prop(ptr.get_prop());
        }
    };
}

#[macro_export]
macro_rules! blocks {
    ($struct_id:ident $static_id:ident [
        $(
            $block_id:ident $block_name:literal $([ $($prop:tt),* ])?
        ),*
        $(,)?
    ]) => {

        #[allow(non_snake_case)]
        pub struct $struct_id {
            blocks: Vec<std::ptr::NonNull<std::pin::Pin<Box<$crate::block::Block>>>>,
            states_count: usize,
            $( pub $block_id: std::pin::Pin<Box<$crate::block::Block>>, )*
            _marker: std::marker::PhantomPinned
        }

        impl $struct_id {
            pub fn load() -> std::pin::Pin<Box<Self>> {

                use $crate::block::{Block, BlockStateBuilder};
                use std::marker::PhantomPinned;
                use std::ptr::NonNull;
                use std::pin::Pin;

                let mut blocks_count = 0;
                let mut states_count = 0;

                let mut inc = |b: Pin<Box<Block>>| {
                    blocks_count += 1;
                    states_count += b.get_states().len();
                    b
                };

                let mut reg = Box::pin(Self {
                    $($block_id: inc(Block::new(
                        $block_name,
                        #[allow(unused_mut)] {
                            let mut b = BlockStateBuilder::with_capacity($crate::count!($($($prop)*)?));
                            $($($crate::inner_blocks_prop!(b, $prop);)*)?
                            b
                        }
                    )),)*
                    blocks: Vec::with_capacity(blocks_count),
                    states_count,
                    _marker: PhantomPinned
                });

                unsafe {
                    let reg_mut = reg.as_mut().get_unchecked_mut();
                    $(reg_mut.blocks.push(NonNull::from(&reg_mut.$block_id));)*
                }

                reg

            }
        }

        // Enforce Send/Sync because NonNull are pointing to pined box content.
        unsafe impl Send for $struct_id {}
        unsafe impl Sync for $struct_id {}

        impl $crate::block::StaticBlocks for $struct_id {

            fn iter_blocks<'a>(&'a self) -> Box<dyn Iterator<Item=&'a std::pin::Pin<Box<$crate::block::Block>>> + 'a> {
                Box::new(self.blocks.iter().map(|ptr| unsafe { ptr.as_ref() }))
            }

            fn blocks_count(&self) -> usize {
                self.blocks.len()
            }

            fn states_count(&self) -> usize {
                self.states_count
            }

        }

        #[allow(non_upper_case_globals)]
        pub static $static_id: once_cell::sync::Lazy<std::pin::Pin<Box<$struct_id>>> = once_cell::sync::Lazy::new(|| $struct_id::load());

    };
}
