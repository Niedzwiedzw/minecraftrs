use std::sync::atomic::{AtomicU32, Ordering};
use std::marker::PhantomPinned;
use std::collections::HashMap;
use std::ptr::NonNull;
use std::fmt::Debug;
use std::any::Any;
use std::pin::Pin;

use crate::generic::{RwGenericMap, GuardedRef, GuardedMut};

mod state;
mod property;
pub use state::*;
pub use property::*;

pub mod vanilla;


/// A basic block defined by a name, its states, properties or extensions.
///
/// A Block can only live in heap memory through a pined box because its states
/// contains a back reference to it. Block and BlockState must not be mutated,
/// only extensions can be 'interior-mutated'.
#[derive(Debug)]
pub struct Block {
    uid: u32,
    name: &'static str,
    states: Vec<BlockState>,
    properties: HashMap<&'static str, SharedProperty>,
    extensions: RwGenericMap,
    default_state_index: usize,
    _marker: PhantomPinned
}

// We enforce Send + Sync because we know that these pointers will never
// be mutated but only immutably referenced.
unsafe impl Send for Block {}
unsafe impl Sync for Block {}

impl Block {

    pub fn new(name: &'static str, state_builder: BlockStateBuilder) -> Pin<Box<Block>> {

        let (properties, states) = state_builder.build();

        let mut block = Box::pin(Block {
            uid: Self::gen_uid(),
            name,
            states,
            properties,
            extensions: RwGenericMap::new(),
            default_state_index: 0,
            _marker: PhantomPinned
        });

        unsafe {

            let block_ref = NonNull::from(&*block);
            let block_mut = block.as_mut().get_unchecked_mut();

            for state in &mut block_mut.states {
                state.set_block(block_ref);
            }

        }

        block

    }

    fn gen_uid() -> u32 {
        // Do not use 0, it's a sentinel for overflow.
        static BLOCK_ID: AtomicU32 = AtomicU32::new(1);
        let ret = BLOCK_ID.fetch_add(1, Ordering::Relaxed);
        if ret == 0 { panic!("Abnormal block count, the global UID overflowed (more than 4 billion).") }
        ret
    }

    pub fn get_uid(&self) -> u32 {
        self.uid
    }

    pub fn get_name(&self) -> &'static str {
        self.name
    }

    pub fn get_default_state(&self) -> &BlockState {
        &self.states[self.default_state_index]
    }

    pub fn get_states(&self) -> &[BlockState] {
        &self.states[..]
    }

    pub fn add_ext<E: Any + Sync + Send>(&self, ext: E) {
        self.extensions.add(ext);
    }

    pub fn get_ext<E: Any + Sync + Send>(&self) -> Option<GuardedRef<E>> {
        self.extensions.get()
    }

    pub fn get_ext_mut<E: Any + Sync + Send>(&self) -> Option<GuardedMut<E>> {
        self.extensions.get_mut()
    }

}


/// Trait to implement for all Blocks static registers, like the one generated by `blocks!` macro.
///
/// This requires the implementation of Any ('static) in order to use the TypeId to resolve
/// UID offset.
pub trait StaticBlocks {
    fn iter_blocks<'a>(&'a self) -> Box<dyn Iterator<Item=&'a Pin<Box<Block>>> + 'a>;
}


pub struct WorkBlocks<'a> {
    next_uid_offset: u16, // 0 is reserved, like the null-ptr
    uid_offsets: HashMap<u32, u16>,
    states: Vec<&'a BlockState>
}

impl<'a> WorkBlocks<'a> {

    pub fn new() -> WorkBlocks<'a> {
        WorkBlocks {
            next_uid_offset: 1,
            uid_offsets: HashMap::new(),
            states: Vec::new()
        }
    }

    pub fn register(&mut self, block: &'a Pin<Box<Block>>) {
        let block = &**block;
        let block_len = block.states.len();
        let uid = self.next_uid_offset;
        self.next_uid_offset = uid.checked_add(block_len as u16)
            .expect("Too much block in this register.");
        self.uid_offsets.insert(block.uid, uid);
        self.states.reserve_exact(block_len);
        for state in &block.states {
            self.states.push(state);
        }
    }

    pub fn register_static(&mut self, static_blocks: &'a Pin<Box<impl StaticBlocks>>) {
        for block in static_blocks.iter_blocks() {
            self.register(block);
        }
    }

    pub fn get_uid_from_state(&self, state: &BlockState) -> Option<u16> {
        let block_uid = state.get_block().uid;
        let block_offset = *self.uid_offsets.get(&block_uid)?;
        Some(block_offset + state.get_uid())
    }

    pub fn get_state_from_uid(&self, uid: u16) -> Option<&'a BlockState> {
        match uid {
            0 => None,
            _ => Some(*self.states.get((uid - 1) as usize)?)
        }
    }

}


#[macro_export]
macro_rules! blocks {
    ($struct_id:ident $static_id:ident [
        $(
            $block_id:ident $block_name:literal $([ $($prop_const:ident),* ])?
        ),*
        $(,)?
    ]) => {

        #[allow(non_snake_case)]
        pub struct $struct_id {
            blocks: Vec<std::ptr::NonNull<std::pin::Pin<Box<$crate::block::Block>>>>,
            $( pub $block_id: std::pin::Pin<Box<$crate::block::Block>>, )*
            _marker: std::marker::PhantomPinned
        }

        impl $struct_id {
            pub fn load() -> std::pin::Pin<Box<Self>> {

                use $crate::block::{Block, BlockStateBuilder};
                use std::marker::PhantomPinned;
                use std::ptr::NonNull;

                let mut count = 0;

                fn inc<T>(v: T, c: &mut usize) -> T {
                    *c += 1;
                    v
                }

                let mut reg = Box::pin(Self {
                    $($block_id: inc(Block::new(
                        $block_name,
                        BlockStateBuilder::with_capacity(0 $($(+ (1, &$prop_const).0)*)?)
                            $($( .prop(&$prop_const) )*)?
                    ), &mut count),)*
                    blocks: Vec::with_capacity(count),
                    _marker: PhantomPinned
                });

                unsafe {
                    let reg_mut = reg.as_mut().get_unchecked_mut();
                    $(reg_mut.blocks.push(NonNull::from(&reg_mut.$block_id));)*
                }

                reg

            }
        }

        // Enforce Send/Sync because NonNull are pointing to pined box content.
        unsafe impl Send for $struct_id {}
        unsafe impl Sync for $struct_id {}

        impl $crate::block::StaticBlocks for $struct_id {

            fn iter_blocks<'a>(&'a self) -> Box<dyn Iterator<Item=&'a std::pin::Pin<Box<$crate::block::Block>>> + 'a> {
                Box::new(self.blocks.iter().map(|ptr| unsafe { ptr.as_ref() }))
            }

        }

        #[allow(non_upper_case_globals)]
        pub static $static_id: once_cell::sync::Lazy<std::pin::Pin<Box<$struct_id>>> = once_cell::sync::Lazy::new(|| $struct_id::load());

    };
}
